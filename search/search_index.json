{
    "docs": [
        {
            "location": "/",
            "text": "zend-permissions-acl\n\n\n\n\n\n\nProvides a lightweight and flexible access control list (ACL) implementation for\nprivileges management.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-permissions-acl/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-permissions-acl/",
            "title": "zend-permissions-acl"
        },
        {
            "location": "/#zend-permissions-acl",
            "text": "Provides a lightweight and flexible access control list (ACL) implementation for\nprivileges management.   File issues at https://github.com/zendframework/zend-permissions-acl/issues  Documentation is at https://docs.zendframework.com/zend-permissions-acl/",
            "title": "zend-permissions-acl"
        },
        {
            "location": "/usage/",
            "text": "Theory and Usage\n\n\nzend-permissions-acl provides a lightweight and flexible access control list (ACL)\nimplementation for privileges management. In general, an application may utilize such ACLs to\ncontrol access to certain protected objects by other requesting objects.\n\n\nFor the purposes of this documentation:\n\n\n\n\na \nresource\n is an object to which access is controlled.\n\n\na \nrole\n is an object that may request access to a resource.\n\n\n\n\nPut simply, \nroles request access to resources\n. For example, if a parking attendant requests\naccess to a car, then the parking attendant is the requesting role, and the car is the resource,\nsince access to the car may not be granted to everyone.\n\n\nThrough the specification and use of an AC*, an application may control how roles are granted\naccess to resources.\n\n\nResources\n\n\nCreating a resource using \nZend\\Permissions\\Acl\\Acl\n is very simple. A resource interface\n\nZend\\Permissions\\Acl\\Resource\\ResourceInterface\n is provided to facilitate creating resources in an\napplication. A class need only implement this interface, which consists of a single method,\n\ngetResourceId()\n, for \nZend\\Permissions\\Acl\\Acl\n to recognize the object as a resource.\nAdditionally, \nZend\\Permissions\\Acl\\Resource\\GenericResource\n is provided as a basic resource\nimplementation for developers to extend as needed.\n\n\nZend\\Permissions\\Acl\\Acl\n provides a tree structure to which multiple resources can be added. Since\nresources are stored in such a tree structure, they can be organized from the general (toward the\ntree root) to the specific (toward the tree leaves). Queries on a specific resource will\nautomatically search the resource's hierarchy for rules assigned to ancestor resources, allowing for\nsimple inheritance of rules. For example, if a default rule is to be applied to each building in a\ncity, one would simply assign the rule to the city, instead of assigning the same rule to each\nbuilding. Some buildings may require exceptions to such a rule, however, and this can be achieved in\n\nZend\\Permissions\\Acl\\Acl\n by assigning such exception rules to each building that requires such an\nexception. A resource may inherit from only one parent resource, though this parent resource can\nhave its own parent resource, etc.\n\n\nZend\\Permissions\\Acl\\Acl\n also supports privileges on resources (e.g., \"create\", \"read\", \"update\",\n\"delete\"), so the developer can assign rules that affect all privileges or specific privileges on\none or more resources.\n\n\nRoles\n\n\nAs with resources, creating a role is also very simple. All roles must implement\n\nZend\\Permissions\\Acl\\Role\\RoleInterface\n. This interface consists of a single method,\n\ngetRoleId()\n, Additionally, \nZend\\Permissions\\Acl\\Role\\GenericRole\n is provided by the\n\nZend\\Permissions\\Acl\n component as a basic role implementation for developers to extend as needed.\n\n\nIn \nZend\\Permissions\\Acl\\Acl\n, a role may inherit from one or more roles. This is to support\ninheritance of rules among roles. For example, a user role, such as \"sally\", may belong to one or\nmore parent roles, such as \"editor\" and \"administrator\". The developer can assign rules to \"editor\"\nand \"administrator\" separately, and \"sally\" would inherit such rules from both, without having to\nassign rules directly to \"sally\".\n\n\nThough the ability to inherit from multiple roles is very useful, multiple inheritance also\nintroduces some degree of complexity. The following example illustrates the ambiguity condition and\nhow \nZend\\Permissions\\Acl\\Acl\n solves it.\n\n\nMultiple Inheritance among Roles\n\n\nThe following code defines three base roles - \"guest\", \"member\", and \"admin\" - from which other\nroles may inherit. Then, a role identified by \"someUser\" is established and inherits from the three\nother roles. The order in which these roles appear in the \n$parents\n array is important. When\nnecessary, \nZend\\Permissions\\Acl\\Acl\n searches for access rules defined not only for the queried\nrole (herein, \"someUser\"), but also upon the roles from which the queried role inherits (herein,\n\"guest\", \"member\", and \"admin\"):\n\n\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\nuse Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource;\n\n$acl = new Acl();\n\n$acl->addRole(new Role('guest'))\n    ->addRole(new Role('member'))\n    ->addRole(new Role('admin'));\n\n$parents = array('guest', 'member', 'admin');\n$acl->addRole(new Role('someUser'), $parents);\n\n$acl->addResource(new Resource('someResource'));\n\n$acl->deny('guest', 'someResource');\n$acl->allow('member', 'someResource');\n\necho $acl->isAllowed('someUser', 'someResource') ? 'allowed' : 'denied';\n\n\n\nSince there is no rule specifically defined for the \"someUser\" role and \"someResource\",\n\nZend\\Permissions\\Acl\\Acl\n must search for rules that may be defined for roles that \"someUser\"\ninherits. First, the \"admin\" role is visited, and there is no access rule defined for it. Next, the\n\"member\" role is visited, and \nZend\\Permissions\\Acl\\Acl\n finds that there is a rule specifying that\n\"member\" is allowed access to \"someResource\".\n\n\nIf \nZend\\Permissions\\Acl\\Acl\n were to continue examining the rules defined for other parent roles,\nhowever, it would find that \"guest\" is denied access to \"someResource\". This fact introduces an\nambiguity because now \"someUser\" is both denied and allowed access to \"someResource\", by reason of\nhaving inherited conflicting rules from different parent roles.\n\n\nZend\\Permissions\\Acl\\Acl\n resolves this ambiguity by completing a query when it finds the first\nrule that is directly applicable to the query. In this case, since the \"member\" role is examined\nbefore the \"guest\" role, the example code would print \"allowed\".\n\n\n\n\nLIFO Order for role queries\n\n\nWhen specifying multiple parents for a role, keep in mind that the last parent listed is the first\none searched for rules applicable to an authorization query.\n\n\n\n\nCreating the Access Control List\n\n\nAn Access Control List (ACL) can represent any set of physical or virtual objects that you wish.\nFor the purposes of demonstration, however, we will create a basic Content Management System (CMS)\nACL that maintains several tiers of groups over a wide variety of areas. To create a new ACL\nobject, we instantiate the ACL with no parameters:\n\n\nuse Zend\\Permissions\\Acl\\Acl;\n$acl = new Acl();\n\n\n\n\n\nDenied by default\n\n\nUntil a developer specifies an \"allow\" rule, \nZend\\Permissions\\Acl\\Acl\n denies access to every\nprivilege upon every resource by every role.\n\n\n\n\nRegistering Roles\n\n\nCMS systems will nearly always require a hierarchy of permissions to determine the authoring\ncapabilities of its users. There may be a 'Guest' group to allow limited access for demonstrations,\na 'Staff' group for the majority of CMS users who perform most of the day-to-day operations, an\n'Editor' group for those responsible for publishing, reviewing, archiving and deleting content, and\nfinally an 'Administrator' group whose tasks may include all of those of the other groups as well as\nmaintenance of sensitive information, user management, back-end configuration data, backup and\nexport. This set of permissions can be represented in a role registry, allowing each group to\ninherit privileges from 'parent' groups, as well as providing distinct privileges for their unique\ngroup only. The permissions may be expressed as follows:\n\n\n\n\n\n\n\n\nName\n\n\nUnique Permissions\n\n\nInherit Permissions From\n\n\n\n\n\n\n\n\n\n\nGuest\n\n\nView\n\n\nN/A\n\n\n\n\n\n\nStaff\n\n\nEdit, Submit, Revise\n\n\nGuest\n\n\n\n\n\n\nEditor\n\n\nPublish, Archive, Delete\n\n\nStaff\n\n\n\n\n\n\nAdministrator\n\n\n(Granted all access)\n\n\nN/A\n\n\n\n\n\n\n\n\nFor this example, \nZend\\Permissions\\Acl\\Role\\GenericRole\n is used, but any object that implements\n\nZend\\Permissions\\Acl\\Role\\RoleInterface\n is acceptable. These groups can be added to the role\nregistry as follows:\n\n\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\n\n$acl = new Acl();\n\n// Add groups to the Role registry using Zend\\Permissions\\Acl\\Role\\GenericRole\n// Guest does not inherit access controls\n$roleGuest = new Role('guest');\n$acl->addRole($roleGuest);\n\n// Staff inherits from guest\n$acl->addRole(new Role('staff'), $roleGuest);\n\n/*\nAlternatively, the above could be written:\n$acl->addRole(new Role('staff'), 'guest');\n*/\n\n// Editor inherits from staff\n$acl->addRole(new Role('editor'), 'staff');\n\n// Administrator does not inherit access controls\n$acl->addRole(new Role('administrator'));\n\n\n\nDefining Access Controls\n\n\nNow that the ACL contains the relevant roles, rules can be established that define how resources\nmay be accessed by roles. You may have noticed that we have not defined any particular resources for\nthis example, which is simplified to illustrate that the rules apply to all resources.\n\nZend\\Permissions\\Acl\\Acl\n provides an implementation whereby rules need only be assigned from\ngeneral to specific, minimizing the number of rules needed, because resources and roles inherit\nrules that are defined upon their ancestors.\n\n\n\n\nSpecificity\n\n\nIn general, \nZend\\Permissions\\Acl\\Acl\n obeys a given rule if and only if a\nmore specific rule does not apply.\n\n\n\n\nConsequently, we can define a reasonably complex set of rules with a minimum amount of code. To\napply the base permissions as defined above:\n\n\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\n\n$acl = new Acl();\n\n$roleGuest = new Role('guest');\n$acl->addRole($roleGuest);\n$acl->addRole(new Role('staff'), $roleGuest);\n$acl->addRole(new Role('editor'), 'staff');\n$acl->addRole(new Role('administrator'));\n\n// Guest may only view content\n$acl->allow($roleGuest, null, 'view');\n\n/*\nAlternatively, the above could be written:\n$acl->allow('guest', null, 'view');\n */\n\n// Staff inherits view privilege from guest, but also needs additional\n// privileges\n$acl->allow('staff', null, array('edit', 'submit', 'revise'));\n\n// Editor inherits view, edit, submit, and revise privileges from\n// staff, but also needs additional privileges\n$acl->allow('editor', null, array('publish', 'archive', 'delete'));\n\n// Administrator inherits nothing, but is allowed all privileges\n$acl->allow('administrator');\n\n\n\nThe \nNULL\n values in the above \nallow()\n calls are used to indicate that the allow rules apply to\nall resources.\n\n\nQuerying an ACL\n\n\nWe now have a flexible ACL that can be used to determine whether requesters have permission to\nperform functions throughout the web application. Performing queries is quite simple using the\n\nisAllowed()\n method:\n\n\necho $acl->isAllowed('guest', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('staff', null, 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('staff', null, 'revise')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('editor', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed because of inheritance from guest\n\necho $acl->isAllowed('editor', null, 'update')\n    ? 'allowed'\n    : 'denied';\n// denied because no allow rule for 'update'\n\necho $acl->isAllowed('administrator', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges\n\necho $acl->isAllowed('administrator')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges\n\necho $acl->isAllowed('administrator', null, 'update')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges",
            "title": "Theory and Usage"
        },
        {
            "location": "/usage/#theory-and-usage",
            "text": "zend-permissions-acl provides a lightweight and flexible access control list (ACL)\nimplementation for privileges management. In general, an application may utilize such ACLs to\ncontrol access to certain protected objects by other requesting objects.  For the purposes of this documentation:   a  resource  is an object to which access is controlled.  a  role  is an object that may request access to a resource.   Put simply,  roles request access to resources . For example, if a parking attendant requests\naccess to a car, then the parking attendant is the requesting role, and the car is the resource,\nsince access to the car may not be granted to everyone.  Through the specification and use of an AC*, an application may control how roles are granted\naccess to resources.",
            "title": "Theory and Usage"
        },
        {
            "location": "/usage/#resources",
            "text": "Creating a resource using  Zend\\Permissions\\Acl\\Acl  is very simple. A resource interface Zend\\Permissions\\Acl\\Resource\\ResourceInterface  is provided to facilitate creating resources in an\napplication. A class need only implement this interface, which consists of a single method, getResourceId() , for  Zend\\Permissions\\Acl\\Acl  to recognize the object as a resource.\nAdditionally,  Zend\\Permissions\\Acl\\Resource\\GenericResource  is provided as a basic resource\nimplementation for developers to extend as needed.  Zend\\Permissions\\Acl\\Acl  provides a tree structure to which multiple resources can be added. Since\nresources are stored in such a tree structure, they can be organized from the general (toward the\ntree root) to the specific (toward the tree leaves). Queries on a specific resource will\nautomatically search the resource's hierarchy for rules assigned to ancestor resources, allowing for\nsimple inheritance of rules. For example, if a default rule is to be applied to each building in a\ncity, one would simply assign the rule to the city, instead of assigning the same rule to each\nbuilding. Some buildings may require exceptions to such a rule, however, and this can be achieved in Zend\\Permissions\\Acl\\Acl  by assigning such exception rules to each building that requires such an\nexception. A resource may inherit from only one parent resource, though this parent resource can\nhave its own parent resource, etc.  Zend\\Permissions\\Acl\\Acl  also supports privileges on resources (e.g., \"create\", \"read\", \"update\",\n\"delete\"), so the developer can assign rules that affect all privileges or specific privileges on\none or more resources.",
            "title": "Resources"
        },
        {
            "location": "/usage/#roles",
            "text": "As with resources, creating a role is also very simple. All roles must implement Zend\\Permissions\\Acl\\Role\\RoleInterface . This interface consists of a single method, getRoleId() , Additionally,  Zend\\Permissions\\Acl\\Role\\GenericRole  is provided by the Zend\\Permissions\\Acl  component as a basic role implementation for developers to extend as needed.  In  Zend\\Permissions\\Acl\\Acl , a role may inherit from one or more roles. This is to support\ninheritance of rules among roles. For example, a user role, such as \"sally\", may belong to one or\nmore parent roles, such as \"editor\" and \"administrator\". The developer can assign rules to \"editor\"\nand \"administrator\" separately, and \"sally\" would inherit such rules from both, without having to\nassign rules directly to \"sally\".  Though the ability to inherit from multiple roles is very useful, multiple inheritance also\nintroduces some degree of complexity. The following example illustrates the ambiguity condition and\nhow  Zend\\Permissions\\Acl\\Acl  solves it.",
            "title": "Roles"
        },
        {
            "location": "/usage/#multiple-inheritance-among-roles",
            "text": "The following code defines three base roles - \"guest\", \"member\", and \"admin\" - from which other\nroles may inherit. Then, a role identified by \"someUser\" is established and inherits from the three\nother roles. The order in which these roles appear in the  $parents  array is important. When\nnecessary,  Zend\\Permissions\\Acl\\Acl  searches for access rules defined not only for the queried\nrole (herein, \"someUser\"), but also upon the roles from which the queried role inherits (herein,\n\"guest\", \"member\", and \"admin\"):  use Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\nuse Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource;\n\n$acl = new Acl();\n\n$acl->addRole(new Role('guest'))\n    ->addRole(new Role('member'))\n    ->addRole(new Role('admin'));\n\n$parents = array('guest', 'member', 'admin');\n$acl->addRole(new Role('someUser'), $parents);\n\n$acl->addResource(new Resource('someResource'));\n\n$acl->deny('guest', 'someResource');\n$acl->allow('member', 'someResource');\n\necho $acl->isAllowed('someUser', 'someResource') ? 'allowed' : 'denied';  Since there is no rule specifically defined for the \"someUser\" role and \"someResource\", Zend\\Permissions\\Acl\\Acl  must search for rules that may be defined for roles that \"someUser\"\ninherits. First, the \"admin\" role is visited, and there is no access rule defined for it. Next, the\n\"member\" role is visited, and  Zend\\Permissions\\Acl\\Acl  finds that there is a rule specifying that\n\"member\" is allowed access to \"someResource\".  If  Zend\\Permissions\\Acl\\Acl  were to continue examining the rules defined for other parent roles,\nhowever, it would find that \"guest\" is denied access to \"someResource\". This fact introduces an\nambiguity because now \"someUser\" is both denied and allowed access to \"someResource\", by reason of\nhaving inherited conflicting rules from different parent roles.  Zend\\Permissions\\Acl\\Acl  resolves this ambiguity by completing a query when it finds the first\nrule that is directly applicable to the query. In this case, since the \"member\" role is examined\nbefore the \"guest\" role, the example code would print \"allowed\".",
            "title": "Multiple Inheritance among Roles"
        },
        {
            "location": "/usage/#lifo-order-for-role-queries",
            "text": "When specifying multiple parents for a role, keep in mind that the last parent listed is the first\none searched for rules applicable to an authorization query.",
            "title": "LIFO Order for role queries"
        },
        {
            "location": "/usage/#creating-the-access-control-list",
            "text": "An Access Control List (ACL) can represent any set of physical or virtual objects that you wish.\nFor the purposes of demonstration, however, we will create a basic Content Management System (CMS)\nACL that maintains several tiers of groups over a wide variety of areas. To create a new ACL\nobject, we instantiate the ACL with no parameters:  use Zend\\Permissions\\Acl\\Acl;\n$acl = new Acl();",
            "title": "Creating the Access Control List"
        },
        {
            "location": "/usage/#denied-by-default",
            "text": "Until a developer specifies an \"allow\" rule,  Zend\\Permissions\\Acl\\Acl  denies access to every\nprivilege upon every resource by every role.",
            "title": "Denied by default"
        },
        {
            "location": "/usage/#registering-roles",
            "text": "CMS systems will nearly always require a hierarchy of permissions to determine the authoring\ncapabilities of its users. There may be a 'Guest' group to allow limited access for demonstrations,\na 'Staff' group for the majority of CMS users who perform most of the day-to-day operations, an\n'Editor' group for those responsible for publishing, reviewing, archiving and deleting content, and\nfinally an 'Administrator' group whose tasks may include all of those of the other groups as well as\nmaintenance of sensitive information, user management, back-end configuration data, backup and\nexport. This set of permissions can be represented in a role registry, allowing each group to\ninherit privileges from 'parent' groups, as well as providing distinct privileges for their unique\ngroup only. The permissions may be expressed as follows:     Name  Unique Permissions  Inherit Permissions From      Guest  View  N/A    Staff  Edit, Submit, Revise  Guest    Editor  Publish, Archive, Delete  Staff    Administrator  (Granted all access)  N/A     For this example,  Zend\\Permissions\\Acl\\Role\\GenericRole  is used, but any object that implements Zend\\Permissions\\Acl\\Role\\RoleInterface  is acceptable. These groups can be added to the role\nregistry as follows:  use Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\n\n$acl = new Acl();\n\n// Add groups to the Role registry using Zend\\Permissions\\Acl\\Role\\GenericRole\n// Guest does not inherit access controls\n$roleGuest = new Role('guest');\n$acl->addRole($roleGuest);\n\n// Staff inherits from guest\n$acl->addRole(new Role('staff'), $roleGuest);\n\n/*\nAlternatively, the above could be written:\n$acl->addRole(new Role('staff'), 'guest');\n*/\n\n// Editor inherits from staff\n$acl->addRole(new Role('editor'), 'staff');\n\n// Administrator does not inherit access controls\n$acl->addRole(new Role('administrator'));",
            "title": "Registering Roles"
        },
        {
            "location": "/usage/#defining-access-controls",
            "text": "Now that the ACL contains the relevant roles, rules can be established that define how resources\nmay be accessed by roles. You may have noticed that we have not defined any particular resources for\nthis example, which is simplified to illustrate that the rules apply to all resources. Zend\\Permissions\\Acl\\Acl  provides an implementation whereby rules need only be assigned from\ngeneral to specific, minimizing the number of rules needed, because resources and roles inherit\nrules that are defined upon their ancestors.",
            "title": "Defining Access Controls"
        },
        {
            "location": "/usage/#specificity",
            "text": "In general,  Zend\\Permissions\\Acl\\Acl  obeys a given rule if and only if a\nmore specific rule does not apply.   Consequently, we can define a reasonably complex set of rules with a minimum amount of code. To\napply the base permissions as defined above:  use Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\n\n$acl = new Acl();\n\n$roleGuest = new Role('guest');\n$acl->addRole($roleGuest);\n$acl->addRole(new Role('staff'), $roleGuest);\n$acl->addRole(new Role('editor'), 'staff');\n$acl->addRole(new Role('administrator'));\n\n// Guest may only view content\n$acl->allow($roleGuest, null, 'view');\n\n/*\nAlternatively, the above could be written:\n$acl->allow('guest', null, 'view');\n */\n\n// Staff inherits view privilege from guest, but also needs additional\n// privileges\n$acl->allow('staff', null, array('edit', 'submit', 'revise'));\n\n// Editor inherits view, edit, submit, and revise privileges from\n// staff, but also needs additional privileges\n$acl->allow('editor', null, array('publish', 'archive', 'delete'));\n\n// Administrator inherits nothing, but is allowed all privileges\n$acl->allow('administrator');  The  NULL  values in the above  allow()  calls are used to indicate that the allow rules apply to\nall resources.",
            "title": "Specificity"
        },
        {
            "location": "/usage/#querying-an-acl",
            "text": "We now have a flexible ACL that can be used to determine whether requesters have permission to\nperform functions throughout the web application. Performing queries is quite simple using the isAllowed()  method:  echo $acl->isAllowed('guest', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('staff', null, 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('staff', null, 'revise')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('editor', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed because of inheritance from guest\n\necho $acl->isAllowed('editor', null, 'update')\n    ? 'allowed'\n    : 'denied';\n// denied because no allow rule for 'update'\n\necho $acl->isAllowed('administrator', null, 'view')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges\n\necho $acl->isAllowed('administrator')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges\n\necho $acl->isAllowed('administrator', null, 'update')\n    ? 'allowed'\n    : 'denied';\n// allowed because administrator is allowed all privileges",
            "title": "Querying an ACL"
        },
        {
            "location": "/refining/",
            "text": "Refining Access Controls\n\n\nPrecise Access Controls\n\n\nThe basic ACL as defined in the [previous section](zend.permissions.acl.introduction) shows how\nvarious privileges may be allowed upon the entire ACL (all resources). In practice, however,\naccess controls tend to have exceptions and varying degrees of complexity.\n\nZend\\Permissions\\Acl\\Acl\n allows to you accomplish these refinements in a straightforward and\nflexible manner.\n\n\nFor the example CMS, it has been determined that whilst the 'staff' group covers the needs of the\nvast majority of users, there is a need for a new 'marketing' group that requires access to the\nnewsletter and latest news in the CMS. The group is fairly self-sufficient and will have the\nability to publish and archive both newsletters and the latest news.\n\n\nIn addition, it has also been requested that the 'staff' group be allowed to view news stories but\nnot to revise the latest news. Finally, it should be impossible for anyone (administrators included)\nto archive any 'announcement' news stories since they only have a lifespan of 1-2 days.\n\n\nFirst we revise the role registry to reflect these changes. We have determined that the 'marketing'\ngroup has the same basic permissions as 'staff', so we define 'marketing' in such a way that it\ninherits permissions from 'staff':\n\n\n// The new marketing group inherits permissions from staff\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\nuse Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource;\n\n$acl = new Acl();\n\n$acl->addRole(new Role('marketing'), 'staff');\n\n\n\nNext, note that the above access controls refer to specific resources (e.g., \"newsletter\", \"latest\nnews\", \"announcement news\"). Now we add these resources:\n\n\n// Create Resources for the rules\n\n// newsletter\n$acl->addResource(new Resource('newsletter'));\n\n// news\n$acl->addResource(new Resource('news'));\n\n// latest news\n$acl->addResource(new Resource('latest'), 'news');\n\n// announcement news\n$acl->addResource(new Resource('announcement'), 'news');\n\n\n\nThen it is simply a matter of defining these more specific rules on the target areas of the ACL:\n\n\n// Marketing must be able to publish and archive newsletters and the\n// latest news\n$acl->allow(\n    'marketing',\n    ['newsletter', 'latest'],\n    ['publish', 'archive']\n);\n\n// Staff (and marketing, by inheritance), are denied permission to\n// revise the latest news\n$acl->deny('staff', 'latest', 'revise');\n\n// Everyone (including administrators) are denied permission to\n// archive news announcements\n$acl->deny(null, 'announcement', 'archive');\n\n\n\nWe can now query the ACL with respect to the latest changes:\n\n\necho $acl->isAllowed('staff', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('staff', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'archive')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'revise')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('editor', 'announcement', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('administrator', 'announcement', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied\n\n\n\nRemoving Access Controls\n\n\nTo remove one or more access rules from the ACL, simply use the available \nremoveAllow()\n or\n\nremoveDeny()\n methods. As with \nallow()\n and \ndeny()\n, you may provide a \nNULL\n value to indicate\napplication to all roles, resources, and/or privileges:\n\n\n// Remove the denial of revising latest news to staff (and marketing,\n// by inheritance)\n$acl->removeDeny('staff', 'latest', 'revise');\n\necho $acl->isAllowed('marketing', 'latest', 'revise')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\n// Remove the allowance of publishing and archiving newsletters to\n// marketing\n$acl->removeAllow(\n    'marketing',\n    'newsletter',\n    ['publish', 'archive']\n);\n\necho $acl->isAllowed('marketing', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'newsletter', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied\n\n\n\nPrivileges may be modified incrementally as indicated above, but a \nNULL\n value for the privileges\noverrides such incremental changes:\n\n\n// Allow marketing all permissions upon the latest news\n$acl->allow('marketing', 'latest');\n\necho $acl->isAllowed('marketing', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'archive')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'anything')\n    ? 'allowed'\n    : 'denied';\n// allowed",
            "title": "Refining ACLs"
        },
        {
            "location": "/refining/#refining-access-controls",
            "text": "",
            "title": "Refining Access Controls"
        },
        {
            "location": "/refining/#precise-access-controls",
            "text": "The basic ACL as defined in the [previous section](zend.permissions.acl.introduction) shows how\nvarious privileges may be allowed upon the entire ACL (all resources). In practice, however,\naccess controls tend to have exceptions and varying degrees of complexity. Zend\\Permissions\\Acl\\Acl  allows to you accomplish these refinements in a straightforward and\nflexible manner.  For the example CMS, it has been determined that whilst the 'staff' group covers the needs of the\nvast majority of users, there is a need for a new 'marketing' group that requires access to the\nnewsletter and latest news in the CMS. The group is fairly self-sufficient and will have the\nability to publish and archive both newsletters and the latest news.  In addition, it has also been requested that the 'staff' group be allowed to view news stories but\nnot to revise the latest news. Finally, it should be impossible for anyone (administrators included)\nto archive any 'announcement' news stories since they only have a lifespan of 1-2 days.  First we revise the role registry to reflect these changes. We have determined that the 'marketing'\ngroup has the same basic permissions as 'staff', so we define 'marketing' in such a way that it\ninherits permissions from 'staff':  // The new marketing group inherits permissions from staff\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Role\\GenericRole as Role;\nuse Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource;\n\n$acl = new Acl();\n\n$acl->addRole(new Role('marketing'), 'staff');  Next, note that the above access controls refer to specific resources (e.g., \"newsletter\", \"latest\nnews\", \"announcement news\"). Now we add these resources:  // Create Resources for the rules\n\n// newsletter\n$acl->addResource(new Resource('newsletter'));\n\n// news\n$acl->addResource(new Resource('news'));\n\n// latest news\n$acl->addResource(new Resource('latest'), 'news');\n\n// announcement news\n$acl->addResource(new Resource('announcement'), 'news');  Then it is simply a matter of defining these more specific rules on the target areas of the ACL:  // Marketing must be able to publish and archive newsletters and the\n// latest news\n$acl->allow(\n    'marketing',\n    ['newsletter', 'latest'],\n    ['publish', 'archive']\n);\n\n// Staff (and marketing, by inheritance), are denied permission to\n// revise the latest news\n$acl->deny('staff', 'latest', 'revise');\n\n// Everyone (including administrators) are denied permission to\n// archive news announcements\n$acl->deny(null, 'announcement', 'archive');  We can now query the ACL with respect to the latest changes:  echo $acl->isAllowed('staff', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('staff', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'archive')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'revise')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('editor', 'announcement', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('administrator', 'announcement', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied",
            "title": "Precise Access Controls"
        },
        {
            "location": "/refining/#removing-access-controls",
            "text": "To remove one or more access rules from the ACL, simply use the available  removeAllow()  or removeDeny()  methods. As with  allow()  and  deny() , you may provide a  NULL  value to indicate\napplication to all roles, resources, and/or privileges:  // Remove the denial of revising latest news to staff (and marketing,\n// by inheritance)\n$acl->removeDeny('staff', 'latest', 'revise');\n\necho $acl->isAllowed('marketing', 'latest', 'revise')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\n// Remove the allowance of publishing and archiving newsletters to\n// marketing\n$acl->removeAllow(\n    'marketing',\n    'newsletter',\n    ['publish', 'archive']\n);\n\necho $acl->isAllowed('marketing', 'newsletter', 'publish')\n    ? 'allowed'\n    : 'denied';\n// denied\n\necho $acl->isAllowed('marketing', 'newsletter', 'archive')\n    ? 'allowed'\n    : 'denied';\n// denied  Privileges may be modified incrementally as indicated above, but a  NULL  value for the privileges\noverrides such incremental changes:  // Allow marketing all permissions upon the latest news\n$acl->allow('marketing', 'latest');\n\necho $acl->isAllowed('marketing', 'latest', 'publish')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'archive')\n    ? 'allowed'\n    : 'denied';\n// allowed\n\necho $acl->isAllowed('marketing', 'latest', 'anything')\n    ? 'allowed'\n    : 'denied';\n// allowed",
            "title": "Removing Access Controls"
        },
        {
            "location": "/ownership/",
            "text": "Ownership Assertions\n\n\n\n\nSince 2.7.0\n\n\n\n\nWhen setting up permissions for an application, site owners common will want to\nallow roles to manipulate resources owned by the user with that role.  For\nexample, a blog author should have permission to \nwrite\n new posts, and also to\n\nmodify\n his or her \nown\n posts, but \nnot\n posts of other authors.\n\n\nTo accomodate this use case, we provide two interfaces:\n\n\n\n\n\n\nZend\\Acl\\ProprietaryInterface\n is applicable to \nresources\n and \nroles\n.\n  It provides information about the \nowner\n of an object. Objects implementing\n  this interface are used in conjunction with the \nOwnershipAssertion\n.\n\n\n\n\n\n\nZend\\Acl\\Assertion\\OwnershipAssertion\n ensures that a resource is owned\n  by a specific role by comparing it to owners provided by\n  \nProprietaryInterface\n implementations.\n\n\n\n\n\n\nExample\n\n\nConsider the following entities:\n\n\nnamespace MyApp\\Entity;\n\nuse Zend\\Permissions\\Acl\\ProprietaryInterface;\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\n\nclass User implements RoleInterface, ProprietaryInterface\n{\n    protected $id;\n\n    protected $role = 'guest';\n\n    public function __construct($id, $role)\n    {\n        $this->id = $id;\n        $this->role = $role;\n    }\n\n    public function getRoleId()\n    {\n        return $this->role;\n    }\n\n    public function getOwnerId()\n    {\n        return $this->id;\n    }\n}\n\nclass BlogPost implements ResourceInterface, ProprietaryInterface\n{\n    public $author = null;\n\n    public function getResourceId()\n    {\n        return 'blogPost';\n    }\n\n    public function getOwnerId()\n    {\n        if ($this->author === null) {\n            return null;\n        }\n\n        return $this->author->getOwnerId();\n    }\n}\n\n\n\nThe \nUser\n marks itself as an \nowner\n by implementing \nProprietaryInterface\n;\nits \ngetOwnerId()\n method will return the user identifier provided during\ninstantiation.\n\n\nA \nBlogPost\n marks itself as a resource and an \nowner\n by also implementing\n\nProprietaryInterface\n; in its case, it returns the author identifier, if\npresent, but \nnull\n otherwise.\n\n\nNow let's wire these up into an ACL:\n\n\nnamespace MyApp;\n\nuse MyApp\\Entity;\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Assertion\\OwnershipAssertion;\n\n$acl = new Acl();\n$acl->addRole('guest');\n$acl->addRole('member', 'guest');\n$acl->addRole('author', 'member');\n$acl->addRole('admin');\n\n$acl->addResource('blogPost');\n$acl->addResource('comment');\n\n$acl->allow('guest', 'blogPost', 'view');\n$acl->allow('guest', 'comment', array('view', 'submit'));\n$acl->allow('author', 'blogPost', 'write');\n$acl->allow('author', 'blogPost', 'edit', new OwnershipAssertion());\n$acl->allow('admin');\n\n$author1 = new User(1, 'author');\n$author2 = new User(2, 'author');\n\n$blogPost = new BlogPost();\n$blogPost->author = $author1;\n\n\n\nThe takeaways from the above should be:\n\n\n\n\nAn \nauthor\n can \nwrite\n blog posts, and \nedit\n posts it owns.\n\n\n$author1\n and \n$author2\n are both authors.\n\n\n$author1\n is the author of \n$blogPost\n.\n\n\n\n\nKnowing these facts, we can expect the following assertion results:\n\n\n$acl->isAllowed($author1, 'blogPost', 'write'); // true\n$acl->isAllowed($author1, $blogPost, 'edit');   // true\n$acl->isAllowed($author2, 'blogPost', 'write'); // true\n$acl->isAllowed($author2, $blogPost, 'edit');   // false",
            "title": "Ownership Assertions"
        },
        {
            "location": "/ownership/#ownership-assertions",
            "text": "Since 2.7.0   When setting up permissions for an application, site owners common will want to\nallow roles to manipulate resources owned by the user with that role.  For\nexample, a blog author should have permission to  write  new posts, and also to modify  his or her  own  posts, but  not  posts of other authors.  To accomodate this use case, we provide two interfaces:    Zend\\Acl\\ProprietaryInterface  is applicable to  resources  and  roles .\n  It provides information about the  owner  of an object. Objects implementing\n  this interface are used in conjunction with the  OwnershipAssertion .    Zend\\Acl\\Assertion\\OwnershipAssertion  ensures that a resource is owned\n  by a specific role by comparing it to owners provided by\n   ProprietaryInterface  implementations.",
            "title": "Ownership Assertions"
        },
        {
            "location": "/ownership/#example",
            "text": "Consider the following entities:  namespace MyApp\\Entity;\n\nuse Zend\\Permissions\\Acl\\ProprietaryInterface;\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\n\nclass User implements RoleInterface, ProprietaryInterface\n{\n    protected $id;\n\n    protected $role = 'guest';\n\n    public function __construct($id, $role)\n    {\n        $this->id = $id;\n        $this->role = $role;\n    }\n\n    public function getRoleId()\n    {\n        return $this->role;\n    }\n\n    public function getOwnerId()\n    {\n        return $this->id;\n    }\n}\n\nclass BlogPost implements ResourceInterface, ProprietaryInterface\n{\n    public $author = null;\n\n    public function getResourceId()\n    {\n        return 'blogPost';\n    }\n\n    public function getOwnerId()\n    {\n        if ($this->author === null) {\n            return null;\n        }\n\n        return $this->author->getOwnerId();\n    }\n}  The  User  marks itself as an  owner  by implementing  ProprietaryInterface ;\nits  getOwnerId()  method will return the user identifier provided during\ninstantiation.  A  BlogPost  marks itself as a resource and an  owner  by also implementing ProprietaryInterface ; in its case, it returns the author identifier, if\npresent, but  null  otherwise.  Now let's wire these up into an ACL:  namespace MyApp;\n\nuse MyApp\\Entity;\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Assertion\\OwnershipAssertion;\n\n$acl = new Acl();\n$acl->addRole('guest');\n$acl->addRole('member', 'guest');\n$acl->addRole('author', 'member');\n$acl->addRole('admin');\n\n$acl->addResource('blogPost');\n$acl->addResource('comment');\n\n$acl->allow('guest', 'blogPost', 'view');\n$acl->allow('guest', 'comment', array('view', 'submit'));\n$acl->allow('author', 'blogPost', 'write');\n$acl->allow('author', 'blogPost', 'edit', new OwnershipAssertion());\n$acl->allow('admin');\n\n$author1 = new User(1, 'author');\n$author2 = new User(2, 'author');\n\n$blogPost = new BlogPost();\n$blogPost->author = $author1;  The takeaways from the above should be:   An  author  can  write  blog posts, and  edit  posts it owns.  $author1  and  $author2  are both authors.  $author1  is the author of  $blogPost .   Knowing these facts, we can expect the following assertion results:  $acl->isAllowed($author1, 'blogPost', 'write'); // true\n$acl->isAllowed($author1, $blogPost, 'edit');   // true\n$acl->isAllowed($author2, 'blogPost', 'write'); // true\n$acl->isAllowed($author2, $blogPost, 'edit');   // false",
            "title": "Example"
        },
        {
            "location": "/expression/",
            "text": "Expression Assertions\n\n\n\n\nSince 2.7.0\n\n\n\n\nMany custom assertions are doing basic comparisons:\n\n\n\n\nEquality of a role property to a value or property of the resource.\n\n\nOther comparisons (\n>\n, \n<\n, \nin_array\n, etc.) of a role property to a value\n  or values (potentially a property of the resource).\n\n\nRegular expressions.\n\n\n\n\nWhile these can be easily accommodated by the \nCallbackAssertion\n, such\nassertions have one notable problem: they cannot be easily serialized.\n\n\nTo facilitate such assertions, we now provide\n\nZend\\Permissions\\Acl\\Assertion\\ExpressionAssertion\n. This class provides two\nstatic factory methods for creating an instance, each expecting the following:\n\n\n\n\nThe left operand\n\n\nAn operator\n\n\nThe right operand\n\n\n\n\nWhen the assertion is executed, it uses the operator to determine how to compare\nthe two operands, and thus answer the assertion.\n\n\nOperands\n\n\nThe operands can be any PHP value.\n\n\nAdditionally, they can be an associative array containing the key\n\nExpressionAssertion::OPERAND_CONTEXT_PROPERTY\n (\n__context\n), with a string\nvalue.\n\n\nThat value can be one of the following:\n\n\n\n\n\n\nA string matching the values \"acl\", \"privilege\", \"role\", or \"resource\", with\n  the latter two being most common. When one of these is provided, the\n  corresponding argument to the \nassert()\n method will be used.\n\n\n\n\n\n\nA dot-separated string with the first segment being one of the above values,\n  and the second being a property or field of that object. The\n  \nExpressionAssertion\n will test for:\n\n\n\n\n\n\na method matching \nget<field>()\n\n\n\n\na method matching \nis<field>()\n\n\na public property named \n<field>\n\n\n\n\nin that specific order. In the first two cases, \n<field>\n will be normalized\n  to WordCase when creating the method name to test.\n\n\nOperators\n\n\nExpressionAssertion\n supports the following operators:\n\n\n    const OPERATOR_EQ     = '=';\n    const OPERATOR_NEQ    = '!=';\n    const OPERATOR_LT     = '<';\n    const OPERATOR_LTE    = '<=';\n    const OPERATOR_GT     = '>';\n    const OPERATOR_GTE    = '>=';\n    const OPERATOR_IN     = 'in';\n    const OPERATOR_NIN    = '!in';\n    const OPERATOR_REGEX  = 'regex';\n    const OPERATOR_NREGEX = '!regex';\n    const OPERATOR_SAME   = '===';\n    const OPERATOR_NSAME  = '!==';\n\n\n\nIn most cases, these will operate using the operators as listed above, with the\nfollowing exceptions:\n\n\n\n\nOPERATOR_EQ\n will use \n==\n as the comparison operator; \nOPERATOR_NEQ\n will\n  likewise use \n!=\n.\n\n\nOPERATOR_IN\n and \nOPERATOR_NIN\n use \nin_array()\n (with the latter negating\n  the result), both doing strict comparisons. The right hand operand is expected\n  to be the array in which to look for results, and the left hand operand is\n  expected to be the needle to look for.\n\n\nOPERATOR_REGEX\n and \nOPERATOR_NREGEX\n will perform a \npreg_match()\n\n  operation, using the right hand operand as the regular expression, and the\n  left hand operand as the value to compare.\n\n\n\n\nConstructors\n\n\nThe constructor of \nExpressionAssertion\n is private. Instead, you will use one\nof two static methods in order to create instances:\n\n\n\n\nfromProperties($left, $operator, $right)\n\n\nfromArray(array $expression)\n (expects keys for \"left\", \"operator\", and \"right\")\n\n\n\n\nWhen creating expressions manually, the first is generally the best choice. When\nstoring expressions in configuration or a database, the latter is useful, as you\ncan pass a row of data at a time to the method to get expression instances.\n\n\nExamples\n\n\nFirst, we'll define both a role and a resource:\n\n\nnamespace Blog\\Entity;\n\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\n\nclass BlogPost implements ResourceInterface\n{\n    public $title;\n\n    public $shortDescription;\n\n    public $content;\n\n    public $author;\n\n    public function __construct(array $data = [])\n    {\n        foreach ($data as $property => $value) {\n            $this->$property = $value;\n        }\n    }\n\n    public function getResourceId()\n    {\n        return 'blogPost';\n    }\n\n    public function getShortDescription()\n    {\n        return $this->shortDescription;\n    }\n\n    public function getAuthorName()\n    {\n        return $this->author ? $this->author->username : '';\n    }\n}\n\nclass User implements RoleInterface\n{\n    public $username;\n\n    public $role = 'guest';\n\n    public $age;\n\n    public function __construct(array $data = [])\n    {\n        foreach ($data as $property => $value) {\n            $this->$property = $value;\n        }\n    }\n\n    public function getRoleId()\n    {\n        return $this->role;\n    }\n\n    public function isAdult()\n    {\n        return $this->age >= 18;\n    }\n}\n\n\n\nNext, let's define some assertions.\n\n\nuse Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion;\n\n// Username of role must be \"test\":\n// Will access $username property on the role instance.\n$isTestUser = ExpressionAssertion::fromProperties(\n  [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.username'],\n  '===',\n  'test'\n);\n\n\n// Role must be at least 18 years old:\n// Will execute `isAdult()` on the role instance.\n$isOfLegalAge = ExpressionAssertion::fromProperties(\n  [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.adult'],\n  '===',\n  true\n);\n\n// Must have edited text:\n// Will do a regex comparison on the shortDescription of the blog post\n// to ensure we do not have filler text.\n$isEditedDescription = ExpressionAssertion::fromArray([\n  'left'     => [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'resource.shortDescription'],\n  'operator' => '!regex',\n  'right'    => '/lorem ipsum/i',\n]);",
            "title": "Expression Assertions"
        },
        {
            "location": "/expression/#expression-assertions",
            "text": "Since 2.7.0   Many custom assertions are doing basic comparisons:   Equality of a role property to a value or property of the resource.  Other comparisons ( > ,  < ,  in_array , etc.) of a role property to a value\n  or values (potentially a property of the resource).  Regular expressions.   While these can be easily accommodated by the  CallbackAssertion , such\nassertions have one notable problem: they cannot be easily serialized.  To facilitate such assertions, we now provide Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion . This class provides two\nstatic factory methods for creating an instance, each expecting the following:   The left operand  An operator  The right operand   When the assertion is executed, it uses the operator to determine how to compare\nthe two operands, and thus answer the assertion.",
            "title": "Expression Assertions"
        },
        {
            "location": "/expression/#operands",
            "text": "The operands can be any PHP value.  Additionally, they can be an associative array containing the key ExpressionAssertion::OPERAND_CONTEXT_PROPERTY  ( __context ), with a string\nvalue.  That value can be one of the following:    A string matching the values \"acl\", \"privilege\", \"role\", or \"resource\", with\n  the latter two being most common. When one of these is provided, the\n  corresponding argument to the  assert()  method will be used.    A dot-separated string with the first segment being one of the above values,\n  and the second being a property or field of that object. The\n   ExpressionAssertion  will test for:    a method matching  get<field>()   a method matching  is<field>()  a public property named  <field>   in that specific order. In the first two cases,  <field>  will be normalized\n  to WordCase when creating the method name to test.",
            "title": "Operands"
        },
        {
            "location": "/expression/#operators",
            "text": "ExpressionAssertion  supports the following operators:      const OPERATOR_EQ     = '=';\n    const OPERATOR_NEQ    = '!=';\n    const OPERATOR_LT     = '<';\n    const OPERATOR_LTE    = '<=';\n    const OPERATOR_GT     = '>';\n    const OPERATOR_GTE    = '>=';\n    const OPERATOR_IN     = 'in';\n    const OPERATOR_NIN    = '!in';\n    const OPERATOR_REGEX  = 'regex';\n    const OPERATOR_NREGEX = '!regex';\n    const OPERATOR_SAME   = '===';\n    const OPERATOR_NSAME  = '!==';  In most cases, these will operate using the operators as listed above, with the\nfollowing exceptions:   OPERATOR_EQ  will use  ==  as the comparison operator;  OPERATOR_NEQ  will\n  likewise use  != .  OPERATOR_IN  and  OPERATOR_NIN  use  in_array()  (with the latter negating\n  the result), both doing strict comparisons. The right hand operand is expected\n  to be the array in which to look for results, and the left hand operand is\n  expected to be the needle to look for.  OPERATOR_REGEX  and  OPERATOR_NREGEX  will perform a  preg_match() \n  operation, using the right hand operand as the regular expression, and the\n  left hand operand as the value to compare.",
            "title": "Operators"
        },
        {
            "location": "/expression/#constructors",
            "text": "The constructor of  ExpressionAssertion  is private. Instead, you will use one\nof two static methods in order to create instances:   fromProperties($left, $operator, $right)  fromArray(array $expression)  (expects keys for \"left\", \"operator\", and \"right\")   When creating expressions manually, the first is generally the best choice. When\nstoring expressions in configuration or a database, the latter is useful, as you\ncan pass a row of data at a time to the method to get expression instances.",
            "title": "Constructors"
        },
        {
            "location": "/expression/#examples",
            "text": "First, we'll define both a role and a resource:  namespace Blog\\Entity;\n\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\n\nclass BlogPost implements ResourceInterface\n{\n    public $title;\n\n    public $shortDescription;\n\n    public $content;\n\n    public $author;\n\n    public function __construct(array $data = [])\n    {\n        foreach ($data as $property => $value) {\n            $this->$property = $value;\n        }\n    }\n\n    public function getResourceId()\n    {\n        return 'blogPost';\n    }\n\n    public function getShortDescription()\n    {\n        return $this->shortDescription;\n    }\n\n    public function getAuthorName()\n    {\n        return $this->author ? $this->author->username : '';\n    }\n}\n\nclass User implements RoleInterface\n{\n    public $username;\n\n    public $role = 'guest';\n\n    public $age;\n\n    public function __construct(array $data = [])\n    {\n        foreach ($data as $property => $value) {\n            $this->$property = $value;\n        }\n    }\n\n    public function getRoleId()\n    {\n        return $this->role;\n    }\n\n    public function isAdult()\n    {\n        return $this->age >= 18;\n    }\n}  Next, let's define some assertions.  use Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion;\n\n// Username of role must be \"test\":\n// Will access $username property on the role instance.\n$isTestUser = ExpressionAssertion::fromProperties(\n  [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.username'],\n  '===',\n  'test'\n);\n\n\n// Role must be at least 18 years old:\n// Will execute `isAdult()` on the role instance.\n$isOfLegalAge = ExpressionAssertion::fromProperties(\n  [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.adult'],\n  '===',\n  true\n);\n\n// Must have edited text:\n// Will do a regex comparison on the shortDescription of the blog post\n// to ensure we do not have filler text.\n$isEditedDescription = ExpressionAssertion::fromArray([\n  'left'     => [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'resource.shortDescription'],\n  'operator' => '!regex',\n  'right'    => '/lorem ipsum/i',\n]);",
            "title": "Examples"
        },
        {
            "location": "/advanced/",
            "text": "Advanced Usage\n\n\nStoring ACL Data for Persistence\n\n\nzend-permissions-acl was designed in such a way that it does not require any\nparticular backend technology such as a database or cache server for storage of the ACL data. Its\ncomplete PHP implementation enables customized administration tools to be built upon\n\nZend\\Permissions\\Acl\\Acl\n with relative ease and flexibility. Many situations require some form of\ninteractive maintenance of the ACL, and \nZend\\Permissions\\Acl\\Acl\n provides methods for setting\nup, and querying against, the access controls of an application.\n\n\nStorage of ACL data is therefore left as a task for the developer, since use cases are expected to\nvary widely for various situations. Because \nZend\\Permissions\\Acl\\Acl\n is serializable, ACL\nobjects may be serialized with PHP's \nserialize() function\n, and the\nresults may be stored anywhere the developer should desire, such as a file, database, or caching\nmechanism.\n\n\nWriting Conditional ACL Rules with Assertions\n\n\nSometimes a rule for allowing or denying a role access to a resource should not\nbe absolute, but dependent upon various criteria. For example, suppose that\ncertain access should be allowed, but only between the hours of 8:00am and\n5:00pm. Another example would be denying access because a request comes from an\nIP address that has been flagged as a source of abuse.\n\nZend\\Permissions\\Acl\\Acl\n has built-in support for implementing rules based\non whatever conditions the developer needs.\n\n\nZend\\Permissions\\Acl\\Acl\n provides support for conditional rules with\n\nZend\\Permissions\\Acl\\Assertion\\AssertionInterface\n. In order to use the rule assertion interface, a\ndeveloper writes a class that implements the \nassert()\n method of the interface:\n\n\nuse Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Assertion\\AssertionInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\n\nclass CleanIPAssertion implements AssertionInterface\n{\n    public function assert(\n        Acl $acl,\n        RoleInterface $role = null,\n        ResourceInterface $resource = null,\n        $privilege = null\n    ) {\n        return $this->_isCleanIP($_SERVER['REMOTE_ADDR']);\n    }\n\n    protected function _isCleanIP($ip)\n    {\n        // ...\n    }\n}\n\n\n\nOnce an assertion class is available, the developer must supply an instance of\nthe assertion class when assigning conditional rules. A rule that is created\nwith an assertion only applies when the assertion method returns \nTRUE\n.\n\n\nuse Zend\\Permissions\\Acl\\Acl;\n\n$acl = new Acl();\n$acl->allow(null, null, null, new CleanIPAssertion());\n\n\n\nThe above code creates a conditional allow rule that allows access to all\nprivileges on everything by everyone, except when the requesting IP is\n\"blacklisted\". If a request comes in from an IP that is not considered \"clean\",\nthen the allow rule does not apply. Since the rule applies to all roles, all\nresources, and all privileges, an \"unclean\" IP would result in a denial of\naccess. This is a special case, however, and it should be understood that in all\nother cases (i.e., where a specific role, resource, or privilege is specified\nfor the rule), a failed assertion results in the rule not applying, and other\nrules would be used to determine whether access is allowed or denied.\n\n\nThe \nassert()\n method of an assertion object is passed the ACL, role,\nresource, and privilege to which the authorization query (i.e., \nisAllowed()\n)\napplies, in order to provide a context for the assertion class to determine its\nconditions where needed.",
            "title": "Advanced Usage"
        },
        {
            "location": "/advanced/#advanced-usage",
            "text": "",
            "title": "Advanced Usage"
        },
        {
            "location": "/advanced/#storing-acl-data-for-persistence",
            "text": "zend-permissions-acl was designed in such a way that it does not require any\nparticular backend technology such as a database or cache server for storage of the ACL data. Its\ncomplete PHP implementation enables customized administration tools to be built upon Zend\\Permissions\\Acl\\Acl  with relative ease and flexibility. Many situations require some form of\ninteractive maintenance of the ACL, and  Zend\\Permissions\\Acl\\Acl  provides methods for setting\nup, and querying against, the access controls of an application.  Storage of ACL data is therefore left as a task for the developer, since use cases are expected to\nvary widely for various situations. Because  Zend\\Permissions\\Acl\\Acl  is serializable, ACL\nobjects may be serialized with PHP's  serialize() function , and the\nresults may be stored anywhere the developer should desire, such as a file, database, or caching\nmechanism.",
            "title": "Storing ACL Data for Persistence"
        },
        {
            "location": "/advanced/#writing-conditional-acl-rules-with-assertions",
            "text": "Sometimes a rule for allowing or denying a role access to a resource should not\nbe absolute, but dependent upon various criteria. For example, suppose that\ncertain access should be allowed, but only between the hours of 8:00am and\n5:00pm. Another example would be denying access because a request comes from an\nIP address that has been flagged as a source of abuse. Zend\\Permissions\\Acl\\Acl  has built-in support for implementing rules based\non whatever conditions the developer needs.  Zend\\Permissions\\Acl\\Acl  provides support for conditional rules with Zend\\Permissions\\Acl\\Assertion\\AssertionInterface . In order to use the rule assertion interface, a\ndeveloper writes a class that implements the  assert()  method of the interface:  use Zend\\Permissions\\Acl\\Acl;\nuse Zend\\Permissions\\Acl\\Assertion\\AssertionInterface;\nuse Zend\\Permissions\\Acl\\Role\\RoleInterface;\nuse Zend\\Permissions\\Acl\\Resource\\ResourceInterface;\n\nclass CleanIPAssertion implements AssertionInterface\n{\n    public function assert(\n        Acl $acl,\n        RoleInterface $role = null,\n        ResourceInterface $resource = null,\n        $privilege = null\n    ) {\n        return $this->_isCleanIP($_SERVER['REMOTE_ADDR']);\n    }\n\n    protected function _isCleanIP($ip)\n    {\n        // ...\n    }\n}  Once an assertion class is available, the developer must supply an instance of\nthe assertion class when assigning conditional rules. A rule that is created\nwith an assertion only applies when the assertion method returns  TRUE .  use Zend\\Permissions\\Acl\\Acl;\n\n$acl = new Acl();\n$acl->allow(null, null, null, new CleanIPAssertion());  The above code creates a conditional allow rule that allows access to all\nprivileges on everything by everyone, except when the requesting IP is\n\"blacklisted\". If a request comes in from an IP that is not considered \"clean\",\nthen the allow rule does not apply. Since the rule applies to all roles, all\nresources, and all privileges, an \"unclean\" IP would result in a denial of\naccess. This is a special case, however, and it should be understood that in all\nother cases (i.e., where a specific role, resource, or privilege is specified\nfor the rule), a failed assertion results in the rule not applying, and other\nrules would be used to determine whether access is allowed or denied.  The  assert()  method of an assertion object is passed the ACL, role,\nresource, and privilege to which the authorization query (i.e.,  isAllowed() )\napplies, in order to provide a context for the assertion class to determine its\nconditions where needed.",
            "title": "Writing Conditional ACL Rules with Assertions"
        }
    ]
}